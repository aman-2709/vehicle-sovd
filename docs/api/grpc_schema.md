# gRPC Schema Documentation

## Overview

This document describes the gRPC Protocol Buffer schema for SOVD (Service-Oriented Vehicle Diagnostics) vehicle communication. The schema defines the service contract between the SOVD Command WebApp backend and connected vehicles.

**Protocol:** gRPC (HTTP/2 with Protocol Buffers)
**Package:** `sovd.vehicle`
**Proto File:** `backend/protos/sovd_vehicle_service.proto`
**Generated Code:** `backend/app/generated/`

---

## Service Definition

### VehicleService

The main gRPC service for vehicle communication.

```protobuf
service VehicleService {
  rpc ExecuteCommand(CommandRequest) returns (stream CommandResponse) {}
}
```

#### Methods

##### ExecuteCommand

Executes an SOVD command on a target vehicle with streaming response support.

**Request:** `CommandRequest`
**Response:** `stream CommandResponse` (server-streaming)
**Pattern:** Unary request → Server-streaming response

**Description:**
- Client sends a single `CommandRequest` with command details
- Server streams multiple `CommandResponse` messages back (one per response chunk)
- Each response includes a `sequence_number` and `is_final` flag
- The final response has `is_final=true`, indicating no more responses will be sent

**Use Case:**
This pattern supports commands that generate multi-part responses (e.g., reading diagnostic trouble codes from multiple ECUs, streaming large data sets).

---

## Message Definitions

### CommandRequest

Request message for executing a command on a vehicle.

```protobuf
message CommandRequest {
  string command_id = 1;
  string vehicle_id = 2;
  string command_name = 3;
  map<string, string> command_params = 10;
}
```

#### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `command_id` | `string` | Yes | Unique identifier for this command execution (UUID format). Example: `"550e8400-e29b-41d4-a716-446655440000"` |
| `vehicle_id` | `string` | Yes | Unique identifier for the target vehicle (UUID format). Example: `"123e4567-e89b-12d3-a456-426614174000"` |
| `command_name` | `string` | Yes | Name of the SOVD command to execute. Examples: `"ReadDTC"`, `"ClearDTC"`, `"ReadDataByID"` |
| `command_params` | `map<string, string>` | No | Command-specific parameters as key-value pairs. For complex nested parameters, values should be JSON-encoded strings. |

#### Field Details

**command_id:**
- Format: UUID v4 string (lowercase with hyphens)
- Generated by the backend when a command is created
- Used to correlate requests and responses across the system
- Must be unique per command execution

**vehicle_id:**
- Format: UUID v4 string (lowercase with hyphens)
- Identifies the target vehicle in the SOVD system
- Must correspond to a registered vehicle in the database
- Used for routing the command to the correct vehicle connection

**command_name:**
- Format: String (typically PascalCase)
- Specifies which SOVD diagnostic operation to perform
- Valid values are defined by the SOVD 2.0 specification
- Common examples:
  - `"ReadDTC"` - Read diagnostic trouble codes
  - `"ClearDTC"` - Clear stored diagnostic codes
  - `"ReadDataByID"` - Read specific data identifiers

**command_params:**
- Format: Map of string keys to string values
- Simple parameters: `{"ecuAddress": "0x10", "dataId": "0x1234"}`
- Complex parameters (JSON-encoded): `{"config": "{\"timeout\": 5000, \"retry\": true}"}`
- Empty map is valid for commands with no parameters
- Parameter validation is performed by `app/services/sovd_protocol_handler.py`

#### Example

```python
from app.generated import sovd_vehicle_service_pb2

request = sovd_vehicle_service_pb2.CommandRequest(
    command_id="550e8400-e29b-41d4-a716-446655440000",
    vehicle_id="123e4567-e89b-12d3-a456-426614174000",
    command_name="ReadDTC",
    command_params={
        "ecuAddress": "0x10",
        "dtcMask": "0xFF"
    }
)
```

---

### CommandResponse

Response message for command execution (supports streaming).

```protobuf
message CommandResponse {
  string command_id = 1;
  string response_payload = 2;
  int32 sequence_number = 3;
  bool is_final = 10;
  string timestamp = 11;
}
```

#### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `command_id` | `string` | Yes | Command identifier matching the `CommandRequest.command_id` (UUID format) |
| `response_payload` | `string` | Yes | Response data from the vehicle (JSON-encoded string) |
| `sequence_number` | `int32` | Yes | Zero-indexed sequence number for ordering response chunks (0, 1, 2, ...) |
| `is_final` | `bool` | Yes | Flag indicating if this is the final response chunk. When `true`, no more responses will be sent. |
| `timestamp` | `string` | Yes | ISO 8601 timestamp when this response was generated. Example: `"2025-10-31T14:30:00.123456"` |

#### Field Details

**command_id:**
- Must match the `command_id` from the corresponding `CommandRequest`
- Used by clients to correlate responses with requests
- Critical for multiplexing multiple concurrent commands

**response_payload:**
- Format: JSON-encoded string
- Contains the actual diagnostic data returned by the vehicle
- Structure varies by command type (see SOVD command schemas)
- Example for ReadDTC: `"{\"dtcs\": [{\"code\": \"P0101\", \"status\": \"active\"}]}"`
- Empty string is valid for commands with no response data

**sequence_number:**
- Format: 32-bit signed integer (sufficient for typical responses)
- Starts at 0 for the first response chunk
- Increments by 1 for each subsequent chunk
- Allows clients to order responses correctly even if received out-of-order
- Typical range: 0-99 (most commands return < 100 chunks)

**is_final:**
- `false` - More response chunks will follow
- `true` - This is the last response chunk (stream will close after this)
- Clients should wait until `is_final=true` before considering the command complete

**timestamp:**
- Format: ISO 8601 string with microseconds (UTC)
- Example: `"2025-10-31T14:30:00.123456"`
- Generated by `datetime.isoformat()` in Python backend
- Used for audit logging, latency tracking, and debugging

#### Example

```python
from app.generated import sovd_vehicle_service_pb2

# First response chunk
response1 = sovd_vehicle_service_pb2.CommandResponse(
    command_id="550e8400-e29b-41d4-a716-446655440000",
    response_payload='{"dtcs": [{"code": "P0101", "status": "active"}]}',
    sequence_number=0,
    is_final=False,
    timestamp="2025-10-31T14:30:00.123456"
)

# Final response chunk
response2 = sovd_vehicle_service_pb2.CommandResponse(
    command_id="550e8400-e29b-41d4-a716-446655440000",
    response_payload='{"dtcs": [{"code": "P0420", "status": "pending"}]}',
    sequence_number=1,
    is_final=True,
    timestamp="2025-10-31T14:30:00.456789"
)
```

---

## Data Type Mappings

### Protobuf to Python Type Conversions

| Protobuf Type | Python Type | Notes |
|---------------|-------------|-------|
| `string` | `str` | UTF-8 encoded |
| `int32` | `int` | 32-bit signed integer (-2,147,483,648 to 2,147,483,647) |
| `bool` | `bool` | `True` or `False` |
| `map<string, string>` | `dict[str, str]` | Key-value pairs |

### UUID Representation

UUIDs are represented as **lowercase strings with hyphens**:
- Format: `"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"`
- Example: `"550e8400-e29b-41d4-a716-446655440000"`
- Python: Use `str(uuid.UUID(...))` to convert

### Timestamp Representation

Timestamps are **ISO 8601 strings** (not `google.protobuf.Timestamp`):
- Format: `"YYYY-MM-DDTHH:MM:SS.ffffff"`
- Example: `"2025-10-31T14:30:00.123456"`
- Python: Use `datetime.datetime.isoformat()`

### JSON Encoding Convention

Complex nested parameters in `command_params` and structured data in `response_payload` are **JSON-encoded strings**:

```python
import json

# Simple parameters (direct mapping)
command_params = {
    "ecuAddress": "0x10",
    "dataId": "0x1234"
}

# Complex parameters (JSON-encoded value)
command_params = {
    "ecuAddress": "0x10",
    "advancedConfig": json.dumps({
        "timeout": 5000,
        "retryAttempts": 3,
        "priority": "high"
    })
}

# Response payload (always JSON-encoded)
response_payload = json.dumps({
    "dtcs": [
        {"code": "P0101", "status": "active"},
        {"code": "P0420", "status": "pending"}
    ]
})
```

---

## Usage Examples

### Client Example (Python)

```python
import grpc
from app.generated import sovd_vehicle_service_pb2
from app.generated import sovd_vehicle_service_pb2_grpc

# Create gRPC channel
channel = grpc.insecure_channel('vehicle.example.com:50051')
stub = sovd_vehicle_service_pb2_grpc.VehicleServiceStub(channel)

# Create request
request = sovd_vehicle_service_pb2.CommandRequest(
    command_id="550e8400-e29b-41d4-a716-446655440000",
    vehicle_id="123e4567-e89b-12d3-a456-426614174000",
    command_name="ReadDTC",
    command_params={"ecuAddress": "0x10", "dtcMask": "0xFF"}
)

# Call streaming RPC
response_stream = stub.ExecuteCommand(request)

# Iterate over streamed responses
for response in response_stream:
    print(f"Chunk {response.sequence_number}:")
    print(f"  Payload: {response.response_payload}")
    print(f"  Final: {response.is_final}")
    print(f"  Timestamp: {response.timestamp}")

    if response.is_final:
        print("Command execution complete!")
        break
```

### Server Example (Python)

```python
import grpc
from concurrent import futures
from app.generated import sovd_vehicle_service_pb2
from app.generated import sovd_vehicle_service_pb2_grpc
from datetime import datetime

class VehicleServiceServicer(sovd_vehicle_service_pb2_grpc.VehicleServiceServicer):
    def ExecuteCommand(self, request, context):
        """Execute command with streaming response."""
        command_id = request.command_id

        # Simulate multiple response chunks
        chunks = [
            {"dtcs": [{"code": "P0101", "status": "active"}]},
            {"dtcs": [{"code": "P0420", "status": "pending"}]},
        ]

        for i, chunk_data in enumerate(chunks):
            is_final = (i == len(chunks) - 1)

            response = sovd_vehicle_service_pb2.CommandResponse(
                command_id=command_id,
                response_payload=json.dumps(chunk_data),
                sequence_number=i,
                is_final=is_final,
                timestamp=datetime.utcnow().isoformat()
            )

            yield response

# Create server
server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
sovd_vehicle_service_pb2_grpc.add_VehicleServiceServicer_to_server(
    VehicleServiceServicer(), server
)
server.add_insecure_port('[::]:50051')
server.start()
server.wait_for_termination()
```

---

## Streaming Pattern

### Server-Streaming RPC

The `ExecuteCommand` RPC uses the **server-streaming pattern**:

1. **Client sends single request:**
   - One `CommandRequest` message with command details

2. **Server streams multiple responses:**
   - Server yields multiple `CommandResponse` messages
   - Each response has incrementing `sequence_number`
   - Responses are sent as soon as available (no buffering)

3. **Client iterates over stream:**
   - Client receives responses in order (gRPC guarantees ordering)
   - Client processes each chunk incrementally
   - Client waits for `is_final=true` to determine completion

4. **Stream termination:**
   - Server closes stream after sending response with `is_final=true`
   - Client detects end-of-stream and stops iteration

### Benefits of Streaming

- **Low latency:** Responses sent immediately as generated (no buffering)
- **Memory efficiency:** Large responses split into manageable chunks
- **Progressive updates:** UI can display partial results in real-time
- **Backpressure:** gRPC flow control prevents overwhelming slow clients

---

## Integration with Existing Code

### Vehicle Connector Integration

The gRPC schema is designed to integrate with the existing `vehicle_connector.py` module:

**Current Mock Implementation:**
- `backend/app/connectors/vehicle_connector.py:315-336` - `execute_command()` function
- Parameters: `command_id`, `vehicle_id`, `command_name`, `command_params`
- Returns: Async generator yielding response chunks

**Mapping:**
- `CommandRequest` fields map 1:1 to `execute_command()` parameters
- `CommandResponse` fields map to response chunk structure
- Streaming pattern matches mock's async generator pattern

**Next Steps (Task I5.T6):**
The real gRPC client implementation will:
1. Create gRPC channel to vehicle endpoint
2. Convert `execute_command()` parameters to `CommandRequest` protobuf
3. Call `VehicleService.ExecuteCommand` RPC
4. Iterate over `CommandResponse` stream
5. Persist each response and publish to Redis (existing logic)

### SOVD Protocol Handler Integration

The gRPC schema supports existing command validation:

**Command Validation:**
- `backend/app/services/sovd_protocol_handler.py` validates commands using JSON Schema
- Validation schemas: `docs/api/sovd_command_schema.json`
- `command_params` map accommodates structured parameters via JSON encoding

**Future Enhancement:**
- Replace JSON Schema validation with protobuf validation
- Define command-specific protobuf messages (e.g., `ReadDTCParams`)
- Use protobuf's built-in type safety instead of runtime JSON validation

---

## Compilation Instructions

### Prerequisites

Ensure gRPC tools are installed:

```bash
pip install grpcio>=1.60.0 grpcio-tools>=1.60.0 grpcio-reflection>=1.60.0
```

### Compile Protobuf

Run the Makefile target:

```bash
make proto
```

This will:
1. Create `backend/app/generated/` directory
2. Compile `sovd_vehicle_service.proto` to Python code
3. Generate:
   - `sovd_vehicle_service_pb2.py` (message classes)
   - `sovd_vehicle_service_pb2_grpc.py` (service stubs)
   - `sovd_vehicle_service_pb2.pyi` (type hints)
4. Fix relative imports for package compatibility
5. Create `__init__.py` to make it a Python package

### Verify Compilation

Test imports:

```bash
cd backend
python -c "from app.generated import sovd_vehicle_service_pb2, sovd_vehicle_service_pb2_grpc; print('Success!')"
```

Or run the test script:

```bash
cd backend
python test_proto_imports.py
```

### Manual Compilation

If you need to compile manually:

```bash
python -m grpc_tools.protoc \
  -I backend/protos \
  --python_out=backend/app/generated \
  --grpc_python_out=backend/app/generated \
  --pyi_out=backend/app/generated \
  backend/protos/sovd_vehicle_service.proto

# Fix imports
sed -i 's/^import sovd_vehicle_service_pb2/from . import sovd_vehicle_service_pb2/' \
  backend/app/generated/sovd_vehicle_service_pb2_grpc.py
```

---

## Error Handling

### gRPC Status Codes

The gRPC implementation will use standard status codes for error handling:

| Status Code | When to Use |
|-------------|-------------|
| `OK` | Successful completion (all response chunks sent with `is_final=true`) |
| `CANCELLED` | Client cancelled the request |
| `INVALID_ARGUMENT` | Invalid `CommandRequest` fields (e.g., malformed UUID) |
| `NOT_FOUND` | Vehicle not found or not connected |
| `DEADLINE_EXCEEDED` | Command execution timeout |
| `UNAVAILABLE` | Vehicle temporarily unavailable (will retry) |
| `INTERNAL` | Unexpected server error |

### Error Responses

Errors are communicated via gRPC status codes, **not** in `CommandResponse` messages:

**Correct:**
```python
# Server sets error status and metadata
context.set_code(grpc.StatusCode.NOT_FOUND)
context.set_details(f"Vehicle {vehicle_id} not found")
return  # Don't yield any responses
```

**Incorrect:**
```python
# Don't put errors in CommandResponse
response = CommandResponse(
    command_id=command_id,
    response_payload='{"error": "Vehicle not found"}',  # ❌ Wrong
    ...
)
```

**Client Error Handling:**
```python
try:
    for response in stub.ExecuteCommand(request):
        # Process response
        pass
except grpc.RpcError as e:
    print(f"Error: {e.code()} - {e.details()}")
```

---

## Performance Considerations

### Message Size Limits

- **Default max message size:** 4 MB (gRPC default)
- **Recommendation:** Keep response chunks < 1 MB each
- **Large responses:** Split into multiple chunks using `sequence_number`

### Concurrent Connections

- **Vehicle Connector:** Supports connection pooling for multiple vehicles
- **Backend Server:** Can handle 100+ concurrent gRPC streams
- **Rate Limiting:** Applied at API layer (not gRPC level)

### Timeout Configuration

Recommended timeout values:

| Operation | Timeout |
|-----------|---------|
| gRPC connection | 10 seconds |
| Command execution | 60 seconds (configurable per command) |
| Stream idle | 30 seconds |

---

## Security

### TLS Configuration

Production deployments MUST use TLS:

```python
# Client
credentials = grpc.ssl_channel_credentials(
    root_certificates=open('ca.pem', 'rb').read()
)
channel = grpc.secure_channel('vehicle.example.com:50051', credentials)

# Server
server_credentials = grpc.ssl_server_credentials(
    [(open('server-key.pem', 'rb').read(), open('server-cert.pem', 'rb').read())]
)
server.add_secure_port('[::]:50051', server_credentials)
```

### Mutual TLS (mTLS)

For vehicle authentication, use mutual TLS with client certificates:

```python
credentials = grpc.ssl_channel_credentials(
    root_certificates=open('ca.pem', 'rb').read(),
    private_key=open('client-key.pem', 'rb').read(),
    certificate_chain=open('client-cert.pem', 'rb').read()
)
```

---

## References

- **SOVD 2.0 Specification:** ASAM SOVD Standard
- **gRPC Documentation:** https://grpc.io/docs/languages/python/
- **Protocol Buffers Guide:** https://protobuf.dev/programming-guides/proto3/
- **Architecture Blueprint:** `docs/architecture/03_System_Structure_and_Data.md`
- **Iteration Plan:** `docs/architecture/02_Iteration_I5.md`

---

## Changelog

### 2025-10-31 - Initial Version
- Created gRPC service definition for SOVD vehicle communication
- Defined `VehicleService` with `ExecuteCommand` server-streaming RPC
- Defined `CommandRequest` and `CommandResponse` message types
- Implemented protobuf compilation pipeline with Makefile target
- Generated Python code with type hints and package structure
